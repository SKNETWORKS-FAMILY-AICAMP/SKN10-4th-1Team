<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>의학 연구 논문 하이브리드 검색 시스템</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* 마크다운 스타일 개선 */
        .assistant-message.markdown-body {
            background: #f1f1f1;
            font-family: 'Noto Sans KR', 'Apple SD Gothic Neo', Arial, sans-serif;
            font-size: 1rem;
            padding: 18px 20px;
            border-radius: 15px;
            margin-bottom: 15px;
            max-width: 80%;
            color: #222;
        }
        .markdown-body pre code {
            background: #23272e;
            color: #e4e4e4;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.98em;
        }
        .markdown-body code:not(pre code) {
            background: #e9ecef;
            color: #c7254e;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.98em;
        }
        body {
            background-color: #f8f9fa;
        }
        .chat-container {
            height: 60vh;
            overflow-y: auto;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .message {
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
        }
        .user-message {
            background-color: #e3f2fd;
            margin-left: auto;
            border-top-right-radius: 2px;
        }
        .assistant-message {
            background-color: #f1f1f1;
            margin-right: auto;
            border-top-left-radius: 2px;
        }
        .input-group {
            margin-top: 20px;
        }
        .sidebar {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            height: 60vh;
            overflow-y: auto;
        }
        .doc-card {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid #e9ecef;
        }
        .doc-card.vector-result {
            border-left-color: #0d6efd;
        }
        .doc-card.graph-result {
            border-left-color: #198754;
        }
        .doc-card:hover {
            background-color: #e9ecef;
        }
        .doc-card.active {
            background-color: #e3f2fd;
            border-left: 3px solid #0d6efd;
        }
        .relation-item {
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 4px;
            background-color: #f8f9fa;
        }
        .connections-panel {
            margin-top: 20px;
        }
        h5 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1rem;
            font-weight: 600;
            color: #495057;
        }
        .loading {
            text-align: center;
            padding: 20px;
            display: none;
        }
    </style>
    <!-- marked.js & highlight.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">의학 연구 논문 하이브리드 검색 시스템</a>
            <span class="badge rounded-pill ms-2" id="queryTypeBadge">
                검색 모드: 준비중
            </span>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="row">
            <!-- 채팅 영역 -->
            <div class="col-md-7">
                <div class="chat-container" id="chatContainer">
                    <div class="assistant-message message markdown-body">
                        안녕하세요! 의학 연구 논문에 대해 질문해 주세요. LangGraph 기반의 하이브리드 검색 시스템이 다음과 같은 방식으로 작동합니다:

1. **벡터 검색**: 유사성 기반 의미적 검색 (예: "비만 치료법에 대한 최신 연구는?")
2. **그래프 검색**: 관계 기반 구조적 검색 (예: "고혈압과 당뇨병의 연관성은?")
3. **하이브리드 검색**: 벡터+그래프 결합 검색 (기본 모드)

질문에 따라 자동으로 최적의 검색 전략을 선택합니다.
                    </div>
                </div>
                <div class="loading" id="loadingIndicator">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">로딩 중...</span>
                    </div>
                    <p class="mt-2">응답 생성 중...</p>
                </div>
                <div class="input-group">
                    <input type="text" id="userInput" class="form-control" placeholder="질문을 입력하세요...">
                    <button class="btn btn-primary" id="sendButton">전송</button>
                </div>
            </div>

            <!-- 정보 패널 -->
            <div class="col-md-5">
                <div class="sidebar">
                    <h4>검색 결과</h4>
                    <div id="retrievedDocs">
                        <p class="text-muted">검색 결과가 여기에 표시됩니다.</p>
                    </div>

                    <h5>관련 정보</h5>
                    <div id="relatedInfo">
                        <p class="text-muted">선택된 논문의 관련 정보가 여기에 표시됩니다.</p>
                    </div>

                    <div class="connections-panel">
                        <h5>논문 간 연결</h5>
                        <div id="connections">
                            <p class="text-muted">선택된 논문과 연결된 다른 논문들이 여기에 표시됩니다.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 쿼리 타입에 따른 배지 색상 설정
            function updateQueryTypeBadge(queryType) {
                const badge = document.getElementById('queryTypeBadge');
                badge.textContent = `검색 모드: ${getQueryTypeLabel(queryType)}`;
                badge.className = 'badge rounded-pill ms-2';
                
                if (queryType === 'vector') {
                    badge.classList.add('bg-primary');
                } else if (queryType === 'graph') {
                    badge.classList.add('bg-success');
                } else if (queryType === 'hybrid') {
                    badge.classList.add('bg-info', 'text-dark');
                } else {
                    badge.classList.add('bg-secondary');
                }
            }
            
            // 쿼리 타입 한글 레이블 반환
            function getQueryTypeLabel(queryType) {
                switch(queryType) {
                    case 'vector': return '벡터 검색';
                    case 'graph': return '그래프 검색';
                    case 'hybrid': return '하이브리드 검색';
                    default: return '준비중';
                }
            }
            
            // 검색 유형에 따른 아이콘 반환
            function getSearchTypeIcon(searchType) {
                if (searchType === 'graph') {
                    return '<i class="bi bi-diagram-3" title="그래프 검색"></i>';
                } else {
                    return '<i class="bi bi-search" title="벡터 검색"></i>';
                }
            }
            const chatContainer = document.getElementById('chatContainer');
            const userInput = document.getElementById('userInput');
            const sendButton = document.getElementById('sendButton');
            const retrievedDocs = document.getElementById('retrievedDocs');
            const relatedInfo = document.getElementById('relatedInfo');
            const connections = document.getElementById('connections');
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            // 대화 기록 관리
            let chatHistory = [];
            
            // 사용자 메시지 전송 함수
            sendButton.addEventListener('click', sendMessage);
            userInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // 부트스트랩 아이콘 추가
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css';
            document.head.appendChild(link);
            
            function sendMessage() {
                const query = userInput.value.trim();
                if (!query) return;
                
                // 사용자 메시지를 채팅창에 추가
                appendMessage(query, 'user');
                userInput.value = '';
                
                // 로딩 인디케이터 표시
                loadingIndicator.style.display = 'block';
                
                // GraphRAG 파이프라인 API 호출
                fetch('/search/?v=' + new Date().getTime(), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        query: query,
                        chat_history: chatHistory
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('서버 응답 오류');
                    }
                    return response.json();
                })
                .then(data => {
                    // 로딩 인디케이터 숨기기
                    loadingIndicator.style.display = 'none';
                    
                    // 응답 처리
                    appendMessage(data.answer, 'assistant');
                    
                    // 메시지 기록 업데이트
                    chatHistory = data.messages;
                    
                    // 쿼리 타입 배지 업데이트
                    updateQueryTypeBadge(data.query_type || 'unknown');
                    
                    // 검색 결과 업데이트
                    updateRetrievedDocs(data.retrieved_docs);
                    
                    // 관련 정보 업데이트
                    updateRelatedInfo(data.related_info);
                    
                    // 연결 정보 업데이트
                    updateConnections(data.connections || []);
                })
                .catch(error => {
                    console.error('오류:', error);
                    loadingIndicator.style.display = 'none';
                    appendMessage('요청 처리 중 오류가 발생했습니다. 다시 시도해 주세요.', 'assistant');
                });
            }
            
            // 메시지를 채팅창에 추가하는 함수
            function appendMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message');
                messageDiv.classList.add(sender + '-message');
                if (sender === 'assistant') {
                    messageDiv.classList.add('markdown-body');
                    // 마크다운 렌더링
                    messageDiv.innerHTML = marked.parse(text, {
                        breaks: true,
                        gfm: true
                    });
                    // 코드 하이라이트 적용
                    messageDiv.querySelectorAll('pre code').forEach(block => {
                        hljs.highlightElement(block);
                    });
                } else {
                    messageDiv.innerText = text;
                }
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            
            // 검색 결과 업데이트 함수
            function updateRetrievedDocs(docs) {
                if (!docs || docs.length === 0) {
                    retrievedDocs.innerHTML = '<p class="text-muted">검색 결과가 없습니다.</p>';
                    return;
                }
                
                retrievedDocs.innerHTML = '';
                docs.forEach((doc, index) => {
                    const docCard = document.createElement('div');
                    docCard.classList.add('doc-card');
                    if (index === 0) docCard.classList.add('active');
                    
                    // 검색 유형에 따른 클래스 추가
                    const searchType = doc.search_type || 'vector';
                    docCard.classList.add(searchType + '-result');
                    
                    // 검색 유형 아이콘
                    const searchTypeIcon = getSearchTypeIcon(searchType);
                    
                    docCard.innerHTML = `
                        <div class="d-flex justify-content-between">
                            <strong>${doc.title}</strong>
                            <span class="search-type">${searchTypeIcon}</span>
                        </div>
                        <p class="small text-muted mb-0">PMID: ${doc.pmid} | 최종 점수: ${doc.similarity ? doc.similarity.toFixed(2) : 'N/A'}</p>
                        ${doc.original_similarity ? 
                          `<p class="small text-muted mb-0">
                            <span>벡터: ${doc.original_similarity.toFixed(2)}</span>
                            ${doc.llm_score ? ` | <span>LLM: ${doc.llm_score.toFixed(2)}</span>` : ''}
                           </p>` 
                          : ''}
                    `;
                    
                    // 문서 카드 클릭 이벤트 추가
                    docCard.addEventListener('click', () => {
                        // 모든 카드에서 active 클래스 제거
                        document.querySelectorAll('.doc-card').forEach(card => {
                            card.classList.remove('active');
                        });
                        // 선택한 카드에 active 클래스 추가
                        docCard.classList.add('active');
                        
                        // 선택한 문서에 대한 관련 정보 요청
                        fetchDocumentInfo(doc.pmid);
                    });
                    
                    retrievedDocs.appendChild(docCard);
                });
                
                // 기본적으로 첫 번째 문서의 정보 표시
                if (docs.length > 0) {
                    fetchDocumentInfo(docs[0].pmid);
                }
            }
            
            // 선택한 문서의 관련 정보 가져오기
            function fetchDocumentInfo(pmid) {
                // 정보 로딩 표시
                relatedInfo.innerHTML = '<p class="text-center"><i class="spinner-border spinner-border-sm"></i> 정보 로딩 중...</p>';
                connections.innerHTML = '<p class="text-center"><i class="spinner-border spinner-border-sm"></i> 정보 로딩 중...</p>';
                
                // 서버에 선택한 문서의 정보 요청
                fetch(`/search/document_info/?pmid=${pmid}&v=${new Date().getTime()}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('서버 응답 오류');
                    }
                    return response.json();
                })
                .then(data => {
                    // 관련 정보 업데이트
                    updateRelatedInfo(data.related_info);
                    
                    // 연결 정보 업데이트
                    updateConnections(data.connections);
                })
                .catch(error => {
                    console.error('문서 정보 요청 오류:', error);
                    relatedInfo.innerHTML = '<p class="text-muted">정보를 가져오는 중 오류가 발생했습니다.</p>';
                    connections.innerHTML = '<p class="text-muted">정보를 가져오는 중 오류가 발생했습니다.</p>';
                });
            }
            
            // 초기 쿼리 타입 상태 설정
            updateQueryTypeBadge('unknown');
            
            // 관련 정보 업데이트 함수
            function updateRelatedInfo(info) {
                if (!info || Object.keys(info).length === 0) {
                    relatedInfo.innerHTML = '<p class="text-muted">관련 정보가 없습니다.</p>';
                    return;
                }
                
                let html = '';
                
                // 저자 정보 처리
                if (info.authors && info.authors.length > 0) {
                    html += '<div class="relation-item"><strong>저자:</strong> ';
                    // 저자 객체에서 full_name 속성 추출
                    const authorNames = info.authors.map(author => {
                        if (typeof author === 'object' && author.full_name) {
                            return author.full_name;
                        }
                        return author; // 이미 문자열인 경우
                    });
                    html += authorNames.join(', ');
                    html += '</div>';
                }
                
                // 키워드 정보 처리
                if (info.keywords && info.keywords.length > 0) {
                    html += '<div class="relation-item"><strong>키워드:</strong> ';
                    // 키워드 객체에서 term 속성 추출
                    const keywordTerms = info.keywords.map(keyword => {
                        if (typeof keyword === 'object' && keyword.term) {
                            return keyword.term;
                        }
                        return keyword; // 이미 문자열인 경우
                    });
                    html += keywordTerms.join(', ');
                    html += '</div>';
                }
                
                // 저널 정보 처리
                if (info.journal) {
                    let journalText = '';
                    if (typeof info.journal === 'object') {
                        journalText = info.journal.name || info.journal.toString();
                        if (info.journal.issn) {
                            journalText += ` (ISSN: ${info.journal.issn})`;
                        }
                    } else {
                        journalText = info.journal;
                    }
                    html += `<div class="relation-item"><strong>저널:</strong> ${journalText}</div>`;
                }
                
                relatedInfo.innerHTML = html || '<p class="text-muted">관련 정보가 없습니다.</p>';
            }
            
            // 연결 정보 업데이트 함수
            function updateConnections(conns) {
                if (!conns || conns.length === 0) {
                    connections.innerHTML = '<p class="text-muted">연결된 논문이 없습니다.</p>';
                    return;
                }
                
                connections.innerHTML = '';
                conns.forEach(conn => {
                    const connItem = document.createElement('div');
                    connItem.classList.add('relation-item');
                    
                    // 연결 정보 표시
                    let relationText = '';
                    
                    // 새로운 API 응답 형식 처리
                    if (conn.shared_node) {
                        const sharedType = conn.shared_node.type || '';
                        const sharedName = conn.shared_node.name || '';
                        const sourceRel = conn.source_relation || '';
                        const targetRel = conn.target_relation || '';
                        
                        // 공유 노드 정보가 있는 새 형식
                        if (sharedName) {
                            relationText = `<span class="badge bg-info">${sharedType}</span> <strong>"${sharedName}"</strong> 기반 연결`;
                        }
                        
                        // 관계 타입 추가
                        if (sourceRel && targetRel) {
                            relationText += `<br><small>(${sourceRel} → ${targetRel})</small>`;
                        }
                    } 
                    // 이전 API 응답 형식과의 호환성 유지
                    else if (conn.connection_description) {
                        relationText = conn.connection_description;
                    }
                    else if (conn.connecting_node) {
                        // connecting_node 객체에서 정보 추출
                        if (typeof conn.connecting_node === 'object') {
                            const nodeType = conn.connecting_node.type || '';
                            const nodeName = conn.connecting_node.name || '';
                            relationText = `<span class="badge bg-info">${nodeType}</span> <strong>"${nodeName}"</strong> 기반 연결`;
                            
                            if (conn.relation_path) {
                                relationText += `<br><small>(${conn.relation_path})</small>`;
                            }
                        } else {
                            relationText = `연결: ${conn.connecting_node}`;
                        }
                    } 
                    else if (conn.relation_path) {
                        relationText = `연결: ${conn.relation_path}`;
                    } 
                    else {
                        relationText = '연결 정보 없음';
                    }
                    
                    connItem.innerHTML = `
                        <strong>${conn.title}</strong>
                        <p class="small text-muted mb-0">PMID: ${conn.pmid}</p>
                        <p class="small">${relationText}</p>
                    `;
                    
                    connections.appendChild(connItem);
                });
            }
            
            // CSRF 토큰 가져오기 함수
            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }
        });
    </script>
</body>
</html>
