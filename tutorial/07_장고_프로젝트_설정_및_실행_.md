# Chapter 7: 장고 프로젝트 설정 및 실행


안녕하세요! 드디어 우리 `SKN10-4th-1Team` 프로젝트 튜토리얼의 마지막 장에 오신 것을 환영합니다! 이전 [제6장: API 엔드포인트 (Django 뷰 & URL)](06_api_엔드포인트__django_뷰___url__.md)에서는 사용자의 질문을 받아 우리 RAG 시스템의 전문가 팀(`HybridGraphFlow`)에게 전달하고, 그 답변을 다시 사용자에게 돌려주는 '소통의 창구'인 API 엔드포인트를 Django를 이용해 만드는 방법을 배웠습니다.

이제 데이터 모델 설계부터 시작해서 데이터 수집, 언어 모델 연동, 검색 기능 구현, RAG 파이프라인 구축, 그리고 API 엔드포인트 제작까지, 우리 프로젝트를 이루는 모든 핵심 조각들을 하나씩 다 맞춰보았습니다. 마지막으로 남은 것은 이 모든 조각들이 잘 맞물려 돌아갈 수 있도록 전체 시스템의 '총괄 관리실'을 설정하고, 실제로 시스템을 '켜서' 우리가 만든 연구 논문 검색 챗봇이 동작하는 모습을 확인하는 것입니다.

이번 장에서는 바로 이 **장고(Django) 프로젝트의 전반적인 환경 설정과 실행 방법**에 대해 알아볼 거예요. 마치 건물의 관리실처럼, 우리 웹 애플리케이션 전체가 원활하게 돌아갈 수 있도록 기반 환경을 설정하고, 애플리케이션 서버를 시작하거나 관리 명령을 실행하는 역할을 담당합니다. 데이터베이스 연결 정보, 보안 설정, 설치된 앱 목록, 정적 파일 경로 등 애플리케이션 운영에 필요한 모든 기본 사항을 정의하고 관리하는 방법을 배울 것입니다.

## 우리 프로젝트의 관리실 살펴보기: 주요 파일과 설정 🏢

우리가 만든 웹 애플리케이션이라는 커다란 건물에는 여러 중요한 시설과 관리 도구가 있습니다. 장고 프로젝트에서는 특정 파일들이 이러한 관리실 역할을 수행합니다.

### 1. `manage.py`: 만능 도구 상자 🛠️

프로젝트의 루트 디렉토리(가장 바깥쪽 폴더)에 있는 `manage.py` 파일은 장고 프로젝트를 관리하기 위한 다양한 명령어를 실행할 수 있는 '만능 도구 상자'와 같습니다. 이 도구 상자를 이용해 우리는 개발 서버를 켜거나, 데이터베이스 설정을 변경하거나, 새로운 기능을 추가하는 등의 작업을 할 수 있습니다.

```python
# manage.py (일부)
import os
import sys

def main():
    # 기본 장고 설정 파일 위치를 알려줍니다.
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    # ... (오류 처리 부분 생략) ...
    execute_from_command_line(sys.argv) # 터미널에서 입력한 명령을 실행합니다.
```
*   `os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')`: 장고에게 "우리 프로젝트의 주요 설정은 `config` 폴더 안의 `settings.py` 파일에 있어!" 라고 알려주는 부분입니다.
*   `execute_from_command_line(sys.argv)`: 우리가 터미널에 `python manage.py <명령어>` 와 같이 입력하면, 그 `<명령어>`에 해당하는 작업을 수행하도록 합니다.

이 파일을 직접 수정할 일은 거의 없지만, 장고 프로젝트를 다루는 내내 가장 많이 사용하는 파일 중 하나가 될 것입니다.

### 2. `config/settings.py`: 중앙 제어판 ⚙️

`config` 폴더 안에 있는 `settings.py` 파일은 우리 프로젝트의 '중앙 제어판'이라고 할 수 있습니다. 이곳에서 웹 애플리케이션의 거의 모든 설정을 관리합니다. 마치 건물의 전기, 수도, 보안 시스템을 한 곳에서 제어하는 패널과 같아요.

#### 비밀번호와 중요 정보는 어디에? `.env` 파일! 🤫

`settings.py`에는 중요한 설정이 많지만, 그중에서도 특히 API 키나 데이터베이스 비밀번호처럼 민감한 정보는 코드에 직접 적어두면 위험합니다. 그래서 우리는 이런 비밀 정보들을 `.env`라는 특별한 파일에 따로 보관하고, `settings.py`에서는 이 `.env` 파일을 읽어와 사용합니다. `.env` 파일은 마치 우리 관리실의 '비밀 금고'와 같아서, 중요한 열쇠들을 안전하게 보관하는 역할을 합니다.

프로젝트 루트 디렉토리에 다음과 같은 내용으로 `.env` 파일을 만들어야 합니다 (실제 값으로 채워주세요!):

```env
# .env (예시)
# 장고 프로젝트의 비밀 키 (아무도 모르게 복잡하게 만드세요!)
SECRET_KEY='여러분의_장고_시크릿_키'

# 개발 모드 설정 (True면 개발 중, False면 실제 서비스 환경)
DEBUG=True 

# Neo4j 데이터베이스 접속 정보
NEO4J_BOLT_URL='bolt://neo4j:여러분의neo4j비밀번호@localhost:7687'

# 구글 Gemini API 키
GEMINI_API_KEY='여러분의_Gemini_API_키'

# (선택) PubMed API 사용 시 이메일
ENTREZ_EMAIL='여러분의_이메일@example.com'

# (선택) OpenAI API 키 (만약 사용한다면)
# OPENAI_API_KEY='여러분의_OpenAI_API_키' 
```
**중요:** `.env` 파일은 절대로 Git 같은 버전 관리 시스템에 포함시키면 안 됩니다! (`.gitignore` 파일에 `.env`를 추가해야 합니다.)

이제 `settings.py` 파일의 주요 항목들을 살펴봅시다.

```python
# config/settings.py (일부 발췌 및 설명)
from pathlib import Path
import os
from dotenv import load_dotenv # .env 파일을 읽기 위한 라이브러리

BASE_DIR = Path(__file__).resolve().parent.parent # 프로젝트의 기본 경로
load_dotenv(os.path.join(BASE_DIR, '.env')) # .env 파일 로드!

# 장고 앱의 보안을 위한 비밀 키 (실제 서비스 시에는 절대로 노출 금지!)
SECRET_KEY = os.getenv('SECRET_KEY', 'default_secret_key_for_development')

# 개발 모드 여부 (True면 오류 발생 시 상세 정보 표시 등)
DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'

# 이 웹 애플리케이션에 접속할 수 있는 허용된 주소 목록
ALLOWED_HOSTS = [] # 개발 중에는 보통 비워두거나 ['localhost', '127.0.0.1'] 사용

# 우리 프로젝트에 설치된 앱(기능 단위) 목록
INSTALLED_APPS = [
    'django.contrib.admin', # 장고 관리자 페이지
    # ... (기본 장고 앱들 생략) ...
    'django.contrib.staticfiles',
    'api', # 우리가 만든 api 앱! (이전 장에서 만들었죠?)
]

# URL 요청을 어떤 규칙 파일(urls.py)에서 처리할지 지정
ROOT_URLCONF = 'config.urls' # config 폴더의 urls.py 파일을 먼저 참조

# 웹 화면(HTML) 파일들이 어디에 있는지 알려줌
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # 프로젝트 루트의 'templates' 폴더를 HTML 파일 경로로 추가
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True, # 각 앱 폴더 안의 templates 폴더도 사용
        # ... (옵션 생략) ...
    },
]

# 장고가 기본적으로 사용하는 데이터베이스 설정 (우리 프로젝트의 주 DB는 Neo4j지만, 장고 자체도 DB가 필요)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # 간단한 SQLite 사용
        'NAME': BASE_DIR / 'db.sqlite3',        # 프로젝트 폴더에 파일로 저장
    }
}

# --- Neomodel (Neo4j 연동) 설정 ---
from neomodel import config as neomodel_config # neomodel의 config 객체 가져오기

# .env 파일에서 Neo4j 접속 주소를 읽어와 neomodel에 설정
NEO4J_BOLT_URL = os.getenv('NEO4J_BOLT_URL', 'bolt://neo4j:your_password@localhost:7687')
neomodel_config.DATABASE_URL = NEO4J_BOLT_URL
print(f"Neomodel DB URL 설정됨: {neomodel_config.DATABASE_URL}")
# --- Neomodel 설정 끝 ---
```
*   `SECRET_KEY`: 장고 애플리케이션의 보안을 위해 사용되는 매우 중요한 비밀 키입니다. `.env` 파일에서 가져옵니다.
*   `DEBUG`: 개발 모드(True)에서는 오류 발생 시 자세한 정보를 보여주고, 실제 서비스(False)에서는 간단한 오류 페이지만 보여줍니다.
*   `INSTALLED_APPS`: 우리 프로젝트에 포함된 '앱'들의 목록입니다. `api` 앱은 [제6장: API 엔드포인트 (Django 뷰 & URL)](06_api_엔드포인트__django_뷰___url__.md)에서 만든 우리의 핵심 기능을 담고 있죠.
*   `ROOT_URLCONF`: 사용자의 웹 요청이 들어왔을 때, 어떤 `urls.py` 파일부터 살펴볼지 알려줍니다. `config.urls`는 프로젝트 전체의 URL을 관리하고, 여기서 다시 `api.urls`로 연결될 수 있습니다.
*   `TEMPLATES`: 우리 웹사이트의 겉모습을 담당하는 HTML 파일들이 어디에 있는지 알려줍니다. `api/chatbot.html` 파일도 여기에 해당됩니다.
*   `DATABASES`: 장고는 자체적으로 사용자 인증, 세션 관리 등을 위해 관계형 데이터베이스를 사용합니다. 우리 프로젝트의 핵심 데이터는 Neo4j에 있지만, 장고를 위해서는 간단한 SQLite DB를 설정해 둡니다.
*   **Neomodel 설정**: 가장 중요한 부분 중 하나! [제1장: 그래프 데이터 모델 (Neo4j 모델)](01_그래프_데이터_모델__neo4j_모델__.md)에서 배운 `neomodel` 라이브러리가 Neo4j 데이터베이스와 통신할 수 있도록 접속 주소(`NEO4J_BOLT_URL`)를 설정합니다. 이 주소 역시 `.env` 파일에서 안전하게 가져옵니다.

### 3. `config/wsgi.py` 와 `config/asgi.py`: 외부와의 통신 게이트웨이 🚪

이 두 파일(`wsgi.py`는 전통적인 웹 서버 방식, `asgi.py`는 비동기 방식)은 우리 장고 애플리케이션이 실제 웹 서버(Nginx, Apache 등)와 어떻게 '대화'할지를 정의하는 '통신 규약 설정 파일'입니다. 개발 중에는 크게 신경 쓰지 않아도 되지만, 실제 서비스를 배포할 때는 중요한 역할을 합니다. 이 파일들도 기본적으로 `config.settings`를 참조하도록 되어 있습니다.

```python
# config/wsgi.py (또는 config/asgi.py) (일부)
import os
from django.core.wsgi import get_wsgi_application # 또는 get_asgi_application

# 여기도 settings.py 파일 위치를 알려줍니다.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
application = get_wsgi_application() # 또는 get_asgi_application()
```
이 파일들은 우리 장고 애플리케이션이라는 '건물'의 정문 역할을 하며, 외부에서 들어오는 요청을 받아 내부 시스템으로 전달합니다.

## 프로젝트 실행 준비: 하나씩 차근차근 🚀

자, 이제 관리실의 주요 시설들을 살펴봤으니, 실제로 건물을 가동시키기 위한 준비를 해봅시다!

1.  **필수 준비물 확인**:
    *   컴퓨터에 **파이썬(Python)**이 설치되어 있어야 합니다. (보통 3.8 버전 이상)
    *   파이썬 패키지 관리자인 **pip**도 필요합니다.
    *   (강력 권장) **가상 환경(virtual environment)**을 사용하는 것이 좋습니다. 가상 환경은 프로젝트마다 독립된 파이썬 실행 환경을 만들어주어, 다른 프로젝트와의 충돌을 막아줍니다.
        ```bash
        # 터미널에서 프로젝트 폴더로 이동 후
        python -m venv venv  # 'venv'라는 이름의 가상 환경 생성
        source venv/bin/activate # Linux/macOS 에서 가상 환경 활성화
        # venv\Scripts\activate  # Windows 에서 가상 환경 활성화
        ```

2.  **`.env` 파일 설정하기**:
    *   위에서 설명한 대로, 프로젝트 루트 디렉토리에 `.env` 파일을 만들고 `SECRET_KEY`, `NEO4J_BOLT_URL`, `GEMINI_API_KEY` 등을 여러분의 실제 값으로 채워주세요. 이것 없이는 우리 시스템이 제대로 작동하지 않아요!

3.  **필요한 프로그램(패키지) 설치하기**:
    *   우리 프로젝트는 Django, neomodel, google-generativeai 등 여러 파이썬 라이브러리를 사용합니다. 이런 라이브러리 목록은 보통 `requirements.txt` 파일에 정리되어 있습니다. 다음 명령어로 한 번에 설치할 수 있습니다.
        ```bash
        pip install -r requirements.txt 
        ```
        (만약 `requirements.txt` 파일이 없다면, 각 라이브러리를 `pip install django neomodel python-dotenv google-generativeai ...` 와 같이 직접 설치해야 합니다.)

4.  **데이터베이스 설정 및 초기화**:
    *   **장고 기본 데이터베이스**: `settings.py`에서 설정한 SQLite 같은 장고용 데이터베이스를 위한 테이블들을 만들어야 합니다. `manage.py`를 사용합니다.
        ```bash
        python manage.py makemigrations 
        python manage.py migrate
        ```
        `makemigrations`는 데이터베이스 변경 사항을 감지하여 설계도를 만들고, `migrate`는 그 설계도대로 실제 데이터베이스에 테이블을 생성하거나 변경합니다.
    *   **Neo4j 데이터베이스**:
        *   Neo4j 서버가 여러분의 컴퓨터나 다른 서버에서 **실행 중**이어야 합니다! Docker를 사용하거나 직접 설치해서 실행할 수 있습니다.
        *   [제1장: 그래프 데이터 모델 (Neo4j 모델)](01_그래프_데이터_모델__neo4j_모델__.md)에서 정의한 `install_neomodel_labels()` 함수를 실행하여 Neo4j에 우리 모델의 인덱스와 제약 조건을 설정하는 것이 좋습니다. 이 함수는 [제2장: 데이터 수집 및 전처리 (스크립트)](02_데이터_수집_및_전처리__스크립트__.md)의 `ingest_data.py` 스크립트 실행 시 자동으로 호출되도록 설정되어 있을 수 있거나, 별도의 `manage.py` 명령어로 만들어 실행할 수도 있습니다. (예: `python manage.py setup_neo4j_schema`)

5.  **우리 데이터 채우기 (복습)**:
    *   아직 Neo4j에 논문 데이터가 없다면, [제2장: 데이터 수집 및 전처리 (스크립트)](02_데이터_수집_및_전처리__스크립트__.md)에서 배운 스크립트들을 실행해야 합니다.
        ```bash
        # 예시: PubMed에서 데이터 가져오기
        python scripts/pubmed_fetch.py 
        # 예시: 가져온 데이터를 Neo4j에 적재 (임베딩 생성 포함 가능)
        python scripts/ingest_data.py 
        ```
        이 과정이 완료되어야 우리 챗봇이 검색할 데이터가 생깁니다!

## 드디어 실행! 우리 챗봇 시스템 깨우기 🤖💡

모든 준비가 끝났습니다! 이제 `manage.py`를 사용하여 장고 개발 서버를 실행시켜 봅시다.

```bash
python manage.py runserver
```

이 명령을 실행하면, 터미널에 다음과 비슷한 메시지가 나타날 것입니다:

```
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).
September 05, 2023 - 15:30:00
Django version 4.2.20, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
Neomodel DB URL 설정됨: bolt://neo4j:여러분의neo4j비밀번호@localhost:7687  <-- (settings.py에서 출력한 메시지)
```
"Starting development server at `http://127.0.0.1:8000/`" 라는 메시지가 보이면 성공입니다! 이제 웹 브라우저를 열고 주소창에 `http://127.0.0.1:8000/` (또는 챗봇 페이지가 연결된 특정 URL, 예를 들어 `http://127.0.0.1:8000/api/search/` - 이 주소는 `settings.py`의 `ROOT_URLCONF`와 `api/urls.py` 설정에 따라 다름)을 입력해보세요. [제6장: API 엔드포인트 (Django 뷰 & URL)](06_api_엔드포인트__django_뷰___url__.md)에서 `search_view`가 GET 요청을 받을 때 `api/chatbot.html`을 보여주도록 설정했다면, 드디어 우리가 만든 챗봇 화면을 만날 수 있을 것입니다!

챗봇 화면에서 질문을 입력하고 전송해보세요. 모든 것이 잘 설정되었다면, 우리 전문가 팀 `HybridGraphFlow`가 열심히 일해서 답변을 생성하고 화면에 보여줄 것입니다. 🎉

## `runserver`는 어떻게 작동할까요? (간단한 내부 원리) 🔍

우리가 `python manage.py runserver` 명령을 실행하면, 장고는 우리 컴퓨터에서 가벼운 웹 서버를 하나 실행시킵니다. 사용자가 브라우저에서 특정 주소(예: `http://127.0.0.1:8000/api/search/`)로 요청을 보내면 어떤 일이 일어날까요?

```mermaid
sequenceDiagram
    participant User as 사용자 (브라우저)
    participant DevServer as Django 개발 서버 (manage.py runserver)
    participant WSGI_ASGI as WSGI/ASGI 핸들러 (config/wsgi.py 또는 asgi.py)
    participant DjangoCore as Django 핵심 엔진
    participant URLsPy as URL 라우터 (urls.py)
    participant ViewsPy as 우리 앱 뷰 (api/views.py)

    User->>DevServer: HTTP 요청 (예: /api/search/ 에 POST로 질문 전송)
    DevServer->>WSGI_ASGI: 요청 전달
    WSGI_ASGI->>DjangoCore: 요청 처리 위임 (settings.py 참조)
    DjangoCore->>URLsPy: 어떤 뷰 함수가 이 URL을 처리하는지 분석 (config.urls -> api.urls)
    URLsPy-->>DjangoCore: "api.views.search_view 함수가 담당합니다!"
    DjangoCore->>ViewsPy: search_view(request) 함수 호출!
    Note right of ViewsPy: search_view 내부에서 HybridGraphFlow 호출, 답변 생성
    ViewsPy-->>DjangoCore: 뷰 함수 결과 (JsonResponse 객체)
    DjangoCore-->>WSGI_ASGI: 응답 전달
    WSGI_ASGI-->>DevServer: 응답 반환
    DevServer-->>User: HTTP 응답 전송 (챗봇 화면에 답변 표시)

```

1.  **사용자 요청**: 사용자가 브라우저에서 질문을 입력하고 전송 버튼을 누르면, 브라우저는 장고 개발 서버로 "이 주소(`http://127.0.0.1:8000/api/search/`)로 이 데이터(질문 내용)를 보내니 처리해줘!" 라는 HTTP 요청을 보냅니다.
2.  **개발 서버 수신 및 전달**: `manage.py runserver`로 실행된 개발 서버가 이 요청을 받습니다.
3.  **WSGI/ASGI 핸들러**: 요청은 `config/wsgi.py` (또는 `asgi.py`)에 정의된 '애플리케이션' 객체로 전달됩니다. 이 객체는 장고의 핵심 엔진과 웹 서버 사이의 다리 역할을 합니다.
4.  **Django 핵심 엔진과 URL 라우팅**: 장고 엔진은 `settings.py`에 정의된 `ROOT_URLCONF` (`config.urls`)를 보고, 요청된 URL(`api/search/`)과 일치하는 패턴을 찾습니다. `config.urls`는 다시 `api.urls`를 참조할 수 있고, 마침내 `api.urls.py`에서 `'search/'` 경로가 `views.search_view` 함수와 연결된 것을 발견합니다.
5.  **뷰 함수 실행**: 장고는 `api/views.py`에 있는 `search_view` 함수를 호출하면서, 사용자의 요청 정보를 담은 `request` 객체를 전달합니다.
6.  **핵심 로직 처리**: `search_view` 함수는 전달받은 질문을 [제5장: RAG 파이프라인 (HybridGraphFlow)](05_rag_파이프라인__hybridgraphflow__.md)에게 넘겨 답변을 생성합니다.
7.  **응답 생성 및 반환**: `search_view`는 생성된 답변을 `JsonResponse` 형태로 만들어 장고 엔진에게 돌려줍니다.
8.  **사용자에게 응답 전송**: 이 `JsonResponse`는 다시 WSGI/ASGI 핸들러와 개발 서버를 거쳐 사용자의 웹 브라우저로 전달됩니다. 브라우저는 이 JSON 데이터를 받아 화면에 예쁘게 표시합니다.

이처럼 `manage.py runserver`는 개발 과정에서 우리 애플리케이션을 쉽게 테스트하고 실행해볼 수 있도록 도와주는 아주 유용한 도구입니다.

## 마무리하며: 전체 여정의 끝, 그리고 새로운 시작 🌟

드디어 `SKN10-4th-1Team` 프로젝트 튜토리얼의 대장정이 막을 내렸습니다! 이번 7개의 챕터를 통해 우리는 다음과 같은 놀라운 여정을 함께했습니다:

*   [제1장: 그래프 데이터 모델 (Neo4j 모델)](01_그래프_데이터_모델__neo4j_모델__.md): 연구 정보를 효과적으로 표현하기 위한 Neo4j 그래프 데이터 모델을 설계하고, `neomodel`을 사용해 파이썬 코드로 정의하는 방법을 배웠습니다.
*   [제2장: 데이터 수집 및 전처리 (스크립트)](02_데이터_수집_및_전처리__스크립트__.md): PubMed 같은 외부 소스에서 논문 데이터를 가져와 파싱하고, 우리 모델에 맞게 변환하여 Neo4j에 저장하는 데이터 파이프라인을 구축했습니다. 텍스트 임베딩 생성의 중요성도 맛보았습니다.
*   [제3장: 언어 모델 연동 (GeminiLLM)](03_언어_모델_연동__geminillm__.md): 구글 Gemini와 같은 강력한 언어 모델을 우리 시스템의 '인공지능 두뇌'로 활용하여, 검색된 정보를 바탕으로 자연스러운 한국어 답변을 생성하는 방법을 익혔습니다.
*   [제4장: 벡터/그래프 검색 저장소 (Neo4jVectorSearch)](04_벡터_그래프_검색_저장소__neo4jvectorsearch__.md): 의미 기반 벡터 검색과 관계 기반 그래프 검색을 결합한 `Neo4jVectorSearch`를 통해, 사용자의 질문 의도에 맞는 최적의 정보를 찾아내는 '슈퍼 사서'를 만들었습니다.
*   [제5장: RAG 파이프라인 (HybridGraphFlow)](05_rag_파이프라인__hybridgraphflow__.md): LangGraph를 활용하여 질문 유형 분석, 검색, 정보 통합, 답변 생성의 전 과정을 유기적으로 연결하는 `HybridGraphFlow`라는 강력한 RAG(검색 증강 생성) 파이프라인을 설계했습니다.
*   [제6장: API 엔드포인트 (Django 뷰 & URL)](06_api_엔드포인트__django_뷰___url__.md): Django를 사용하여 웹 브라우저 같은 외부 시스템이 우리 RAG 파이프라인과 통신할 수 있도록 하는 API 엔드포인트를 구축했습니다.
*   그리고 이번 제7장에서는 이 모든 것을 하나로 묶어 실제 Django 프로젝트를 설정하고 실행하여, 우리가 만든 연구 논문 검색 챗봇 시스템이 동작하는 모습을 직접 확인하는 방법을 배웠습니다.

이 튜토리얼을 통해 여러분은 복잡한 아이디어를 실제 작동하는 시스템으로 구현하는 전체 과정을 경험하셨기를 바랍니다. 여기서 배운 지식과 기술은 앞으로 여러분이 자신만의 멋진 프로젝트를 만들어나가는 데 훌륭한 밑거름이 될 것입니다.

비록 이 튜토리얼은 여기서 마무리되지만, 여러분의 학습 여정은 이제부터가 진짜 시작입니다! 코드를 직접 수정해보고, 새로운 기능을 추가해보고, 성능을 개선해보면서 끊임없이 탐구하고 발전해나가시길 응원합니다.

지금까지 함께해주셔서 정말 감사합니다! 여러분의 앞날에 멋진 성과와 배움이 가득하기를 바랍니다. 화이팅! 😊

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)
